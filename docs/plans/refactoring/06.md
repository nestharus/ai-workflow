I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\exception-patterns.md(NEW)

References:

- app\core\exceptions.py
- app\contracts\errors.py
- app\core\factory.py
- tests\unit\test_validation_errors.py
- app\contracts\example_contract.py

Create exception handling patterns documentation covering:

**1. Exception Hierarchy**
- Define `DomainError` base class for all business logic exceptions (to be created in `app/core/errors.py`)
- Create specific exceptions: `ResourceNotFoundError`, `ValidationError`, `UnauthorizedError`
- Use `HTTPException` only for HTTP-specific errors (rate limiting, auth)
- Reference `app/contracts/errors.py` for error response models

**2. AppError Response Model**
- Create `AppError` Pydantic model with `code`, `message`, `status_code` fields (to be created)
- Use for consistent error responses across all endpoints
- Include in OpenAPI schema via `responses` parameter
- Example: `responses={404: {"model": AppError, "description": "Not found"}}`

**3. Global Exception Handlers**
- Register handlers in `app/core/factory.py` using `app.add_exception_handler()`
- Current handler: `RequestValidationError` → `HTTPValidationError` (reference `app/core/exceptions.py` lines 35-66)
- Add handler for `DomainError` → `AppError` response (to be implemented)
- Handlers should return `ORJSONResponse` for consistency

**4. Validation Error Handling**
- Current implementation in `app/core/exceptions.py` is solid
- Sanitizes Pydantic errors (lines 25-32) to prevent information leakage
- Limits error count to `MAX_VALIDATION_ERRORS` (32)
- Optionally includes request body when `include_error_body=True` (lines 45-51)
- Returns structured `HTTPValidationError` model (reference `app/contracts/errors.py` lines 31-49)

**5. Domain Exception Pattern**
- Services raise domain exceptions (e.g., `UserNotFoundError(user_id)`)
- Global handler converts to HTTP response with appropriate status code
- Example: `ResourceNotFoundError` → 404, `ValidationError` → 400, `UnauthorizedError` → 401
- Keep domain exceptions HTTP-agnostic (no status codes in exception class)

**6. Custom Exception Handler Implementation**
- Use `@app.exception_handler(ExceptionType)` decorator
- Handler signature: `async def handler(request: Request, exc: ExceptionType) -> Response`
- Log exceptions appropriately (reference line 53 for logging pattern)
- Return consistent error format using `AppError` model

**7. Error Response Structure**
- Validation errors: use `HTTPValidationError` with `detail` array (reference `app/contracts/errors.py`)
- Domain errors: use `AppError` with single error object
- Include error code for client-side handling: `{"code": "USER_NOT_FOUND", "message": "...", "status_code": 404}`
- Never expose internal error details (stack traces, DB errors) in production

**8. Error Logging**
- Log all errors with appropriate level (reference line 53 for warning level)
- Include request context: method, path, user ID
- Truncate large error messages (reference line 57 for truncation pattern)
- Use structured logging for better observability

**9. OpenAPI Error Documentation**
- Document all possible error responses in route decorators
- Use `VALIDATION_ERROR_RESPONSE` constant (reference `app/contracts/errors.py` line 51)
- Example: `responses={400: VALIDATION_ERROR_RESPONSE, 404: {"model": AppError}}`
- Include error examples in OpenAPI schema

**10. Testing Exception Handlers**
- Test validation errors with invalid input (reference `tests/unit/test_validation_errors.py`)
- Test domain exceptions with mocked services
- Verify error response format and status codes
- Test with and without `include_error_body` setting (lines 70-85)

**11. Anti-Patterns to Avoid**
- Raising `HTTPException` from services (use domain exceptions)
- Returning different error formats from different endpoints
- Exposing internal error details to clients
- Not logging exceptions before returning responses
- Using generic `Exception` instead of specific exception types