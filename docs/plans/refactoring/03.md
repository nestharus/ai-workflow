I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\router-patterns.md(NEW)

References:

- app\api\v1\endpoints\example.py
- app\api\v1\endpoints\health.py
- app\api\v1\router.py
- app\contracts\example_contract.py
- app\core\factory.py
- app\core\exceptions.py

Create router patterns documentation covering:

**1. APIRouter Organization**
- One router per domain/resource (users, items, orders)
- Use `APIRouter()` instances, not direct `@app` decorators (reference `app/api/v1/endpoints/example.py` line 12)
- Group related endpoints in same router file
- Register routers in `app/api/v1/router.py` with appropriate prefixes and tags

**2. Router Configuration**
- Set `prefix` at router level for common path segments (e.g., `prefix="/items"`)
- Set `tags` for OpenAPI grouping (reference `app/api/v1/router.py` lines 9-10)
- Set router-level `dependencies` for shared auth/validation (to be implemented)
- Set common `responses` for error documentation

**3. Route Handler Structure**
- Keep handlers thin: validate input → call service → return response
- Use `Annotated` with `Depends()` for dependency injection (reference `app/api/v1/endpoints/example.py` line 51)
- Always specify `response_model` for automatic validation and OpenAPI docs
- Include `summary`, `description`, and `responses` parameters

**4. Dependency Injection in Routers**
- Use `Depends()` for services, database sessions, current user, etc.
- Create type aliases with `Annotated` for reusable dependencies
- Example: `Annotated[ExampleService, Depends(get_example_service)]`
- Centralize dependency providers in `app/api/v1/dependencies.py` (to be created)

**5. Request Validation**
- Use Pydantic models for request bodies (reference `app/contracts/example_contract.py`)
- Use `Query`, `Path`, `Header` for parameter validation
- Leverage `Field` constraints for validation rules
- Custom validators in Pydantic models, not in route handlers

**6. Response Handling**
- Return Pydantic models directly (FastAPI serializes automatically)
- Use `status_code` parameter for non-200 responses (e.g., `status_code=201` for POST)
- For no-content responses, use `status_code=204` and `response_model=None`
- Reference `ORJSONResponse` default in `app/core/factory.py` line 80

**7. Error Handling in Routers**
- Let services raise domain exceptions
- Global exception handlers convert to HTTP responses (reference `app/core/exceptions.py`)
- Only raise `HTTPException` for router-specific errors (auth, rate limiting)
- Document error responses in `responses` parameter

**8. OpenAPI Documentation**
- Every route must have `summary` (appears in API docs sidebar)
- Complex routes need `description` (detailed explanation with examples)
- Document all possible responses with `responses` parameter
- Example: `app/api/v1/endpoints/example.py` lines 37-49 shows complete documentation

**9. Router Registration**
- Register routers in `app/api/v1/router.py` using `include_router()`
- Apply version prefix in `app/core/factory.py` (reference line 85)
- Order matters: more specific routes before generic ones
- Use `prefix` and `tags` parameters when including routers

**10. Anti-Patterns to Avoid**
- Business logic in route handlers (use services)
- Direct database access in routers (use services/repositories)
- Inconsistent error handling (let global handlers manage it)
- Missing OpenAPI documentation
- Mixing sync and async route handlers without proper handling