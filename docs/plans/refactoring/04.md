I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\factory-patterns.md(NEW)

References:

- app\core\factory.py
- app\core\settings.py
- app\core\exceptions.py
- app\infrastructure\db_connections.py
- tests\conftest.py

Create factory patterns documentation covering:

**1. Application Factory Pattern**
- Use `create_app(settings: Settings)` function for app instantiation (reference `app/core/factory.py` lines 66-121)
- Accept `Settings` as parameter for testability
- Configure all middleware, exception handlers, and routers in factory
- Return fully configured `FastAPI` instance

**2. Lifespan Management**
- Use `@asynccontextmanager` for lifespan events (reference `app/core/factory.py` lines 33-63)
- Initialize resources (DB pools, caches) in startup phase
- Store resources in `app.state` for access via dependencies
- Clean up resources in shutdown phase with proper error handling
- Example: SurrealDB pool initialization at lines 39-41, cleanup at lines 57-61

**3. Resource Initialization**
- Create connection pools during startup (reference `app/infrastructure/db_connections.py`)
- Use factory functions: `create_surrealdb_pool()`, `create_elasticsearch_wrapper()`
- Store in `app.state` for dependency injection: `app.state.surrealdb_pool`, `app.state.elasticsearch_client`
- Initialize schemas/indices during startup (lines 416, 434)

**4. Exception Handler Registration**
- Register custom exception handlers in factory (reference line 86)
- Use `app.add_exception_handler()` for global error handling
- Example: `RequestValidationError` handler in `app/core/exceptions.py`
- Order matters: specific handlers before generic ones

**5. Middleware Configuration**
- Add middleware in correct order (to be documented in middleware-patterns.md)
- Use `app.add_middleware()` method
- Configure middleware with settings from `Settings` object
- Example order: TrustedHost → Security → GZip

**6. Router Registration**
- Include routers with `app.include_router()` (reference line 85)
- Apply version prefix: `prefix="/api/v1"`
- Register health check separately (line 87) without version prefix
- Use `include_in_schema=False` for internal endpoints

**7. OpenAPI Customization**
- Customize OpenAPI schema generation (reference lines 89-119)
- Add custom error schemas to components (lines 104-111)
- Flatten nested `$defs` for cleaner schema (lines 108-111)
- Normalize validation error schemas (lines 112-116)

**8. Settings Integration**
- Store settings in `app.state.settings` (reference line 83)
- Access via dependency injection in routes
- Use for feature flags, environment-specific config
- Reference `app/core/settings.py` for settings structure

**9. Testing Factory Usage**
- Create test app instances with test settings (reference `tests/conftest.py` lines 87-89)
- Override dependencies for testing (to be documented in api-testing-patterns.md)
- Use separate settings for test environment

**10. Anti-Patterns to Avoid**
- Creating global `app` instance at module level (use factory)
- Initializing resources outside lifespan context
- Not cleaning up resources in shutdown phase
- Hardcoding configuration instead of using Settings
- Mixing application logic with factory configuration