Plan 06 – docs/exception-patterns.md (Error Handling Patterns)
Intro Proposal:
NOTE TO GENERATOR (DO NOT EMIT IN OUTPUT):

You are generating `docs/exception-patterns.md`, one document in a FastAPI backend patterns series.

Global goals:
- Define a unified error-handling strategy for the application.
- Ensure all non-2xx responses use a consistent JSON error shape compatible with the frontend.
- Use `fastapi-best-practices.md` / `fastapi-best-practices-2.md` as the reference for error model shape and behavior; treat `api-patterns-guide.md` as secondary.

Specific scope for `exception-patterns.md`:
- Define the exception hierarchy for domain/business errors (e.g. `DomainError`, `ResourceNotFoundError`, `ValidationError`, `UnauthorizedError`).
- Define the `AppError` (and related) Pydantic models, including fields such as `code`, `message`, `statusCode`, and optional `details`.
- Show how global exception handlers map domain errors, validation errors, and unexpected exceptions into consistent HTTP responses.
- Explain how validation errors (FastAPI’s `RequestValidationError`) are normalized (e.g., 400 instead of 422) and sanitized.
- Describe error logging patterns (levels, truncation, including request context) without referencing specific line numbers.
- Document how error responses are represented in OpenAPI (`responses`, shared error components).

Out of scope:
- HTTP-layer API behavior already covered in `api-patterns.md`.
- Service/repository-specific details (handled in their own docs).

Start the final document with the exception patterns heading, not this note.
Mistakes/Issues:
- Naming and consistency: The plan proposes an AppError Pydantic model with code , message ,
  status_code . However, the earlier API Patterns plan (01) and the source “API patterns guide” suggest
  aligning with a frontend expecting statusCode (camelCase) and possibly a details field . It’s a
  potential mistake that the plan switched to snake_case here. Consider using statusCode in the JSON
  output (you can still use Python field name status_code with an alias). Also, include an optional
  details field for extra info (especially useful for validation errors or complex domain errors). Maintaining
  a single consistent error shape is vital . Make sure the documentation highlights that consistency.
- ErrorCode enum: The plan mentions code but doesn’t define how codes are managed. It would improve
  clarity to mention an ErrorCode enum for known error identifiers (e.g. USER_NOT_FOUND ,
  VALIDATION_ERROR ). In the source material, an ErrorCode enum was used . Introducing this
  concept in the documentation (and code) ensures that AppError.code is not an arbitrary string but one
  from a controlled vocabulary. This was likely omitted by mistake.
- File references: Similar to others – instead of “reference app/core/exceptions.py lines 35-66”,
  summarize what that code does. For example, explain: “the global handler for RequestValidationError
  in core/exceptions.py converts FastAPI’s 422 errors to our 400-error schema.” This tells the story without
  needing to read the source. Use a snippet or description for how DomainError will be handled (since that
  code is to be implemented).
- Domain vs HTTP exception explanation: The doc assumes the reader knows the difference between
  raising a HTTPException and a domain exception. It might be good to explicitly state: “In router functions,
  avoid raising HTTPException for errors arising from business logic. Instead, have the service raise a
  DomainError (like ResourceNotFoundError ), and rely on the global exception handler to translate it to
  an HTTP response. Reserve fastapi.HTTPException for truly HTTP-related issues (auth, malformed requests,
  etc.).” This drives home the pattern.
- Logging patterns: It references “line 53 for logging pattern” and “line 57 for truncation.” Rather than that,
  describe the logging approach: e.g. “Our exception handlers log warnings for expected errors (at WARN
  level, including request info) and errors for unexpected ones. They truncate overly long messages (e.g. large
  validation error details) to avoid flooding logs.” This conveys the practice without line numbers.
  Missing Best Practices:
- Don’t catch exceptions to return default 500: The documentation could mention that any exception not
  handled explicitly will result in a 500 with an internal error AppError . It’s implied but not stated. For
  completeness, note that an uncaught exception will be handled by FastAPI (or by a generic handler if we
  add one) – and emphasize that we should not blanket-catch exceptions in handlers (to avoid masking
  errors).
- Deprecation of 422 status: Since the plan uses 400 for validation, you might explicitly mention that
  FastAPI’s default 422 is replaced. The exception handler is doing this, but note in the text: “We override
  FastAPI’s default 422 Unprocessable Entity for validation issues and use 400 Bad Request instead, through
  our handler.” This informs readers of the rationale (consistency with other APIs, perhaps).
- Example error payloads: It could help to provide an example JSON of an error response in the docs. For
  instance:
  {
  "code": "USER_NOT_FOUND",
  "message": "User with ID 123 not found",
  "statusCode": 404
  }
  and for validation errors (HTTPValidationError):
  {
  "detail": [
  {"loc": ["body","name"], "msg": "field required", "type":
  "value_error.missing"}
  ]
  }
  and explain that the second case is FastAPI’s standard validation format (unless you wrap it in AppError as
  well). Showing these will make the abstract discussion more concrete.
- Link to FastAPI docs: It might be useful to reference FastAPI’s docs on exception handlers for further
  reading. Not mandatory, but if a reader needs more context, a link can help (for example, FastAPI
  documentation on exception handling covers RequestValidationError handling).