I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\connection-pooling-patterns.md(NEW)

References:

- app\infrastructure\db_connections.py
- app\core\factory.py
- app\core\settings.py
- tests\conftest.py
- tests\unit\test_validation_errors.py

Create connection pooling patterns documentation covering:

**1. Connection Pooling Fundamentals**
- Create pool once at startup, reuse for all requests
- Never create engine/pool inside request handlers
- Store pool in `app.state` for access via dependencies
- Reference `app/core/factory.py` lines 39-44 for initialization pattern

**2. SurrealDB Connection Pool**
- Current implementation in `app/infrastructure/db_connections.py` is excellent
- Uses `asyncio.Queue` for connection pooling (line 81)
- Pool size configurable via settings (line 103: `surrealdb_pool_size`)
- Connections authenticated and database selected at initialization (lines 92-97)
- Acquire with timeout to prevent deadlocks (lines 122-135)

**3. SurrealDB Pool Configuration**
- Default pool size: 5 connections (line 68)
- Acquire timeout: 10 seconds (line 70)
- Embedding dimension: 768 (line 69, for vector search)
- All configurable via `Settings` class
- Reference `app/core/settings.py` for configuration

**4. SurrealDB Connection Lifecycle**
- Initialize pool in lifespan startup (reference `app/core/factory.py` lines 39-41)
- Use `async with pool.acquire() as conn` for safe connection handling (lines 122-135)
- Connection automatically returned to pool after use
- Close all connections in lifespan shutdown (lines 57-61)

**5. Elasticsearch Connection Pool**
- Uses built-in connection pooling from `elasticsearch` library (line 287)
- Configure `connections_per_node` (line 289, default 25)
- Configure `request_timeout` (line 290, default 10 seconds)
- Configure `retry_on_timeout` (line 291, default True)
- All operations run in threadpool via `anyio.to_thread.run_sync` (lines 304, 320, 331)

**6. Elasticsearch Configuration**
- Number of shards: configurable (line 294, default 1)
- Number of replicas: configurable (line 295, default 0)
- Connection pool managed internally by client
- Initialize indices during startup (lines 364-400)

**7. Pool Size Tuning**
- Start with conservative sizes (5-10 connections)
- Monitor pool exhaustion (timeout errors)
- Formula: `workers × pool_size` should be < DB max connections
- Increase only if profiling shows connection bottleneck
- Reference 2024 best practices: pool_size=5-10, max_overflow=10-20

**8. Connection Timeout Handling**
- SurrealDB: 10 second acquire timeout (line 83)
- Elasticsearch: 10 second request timeout (line 107)
- Log timeout errors for monitoring
- Consider increasing timeout before increasing pool size
- Reference `app/infrastructure/db_connections.py` lines 128-131 for timeout handling

**9. Connection Recycling**
- SurrealDB: connections persist for application lifetime
- Elasticsearch: consider `pool_recycle=1800` (30 minutes) for long-lived apps
- Prevents stale connections with proxies (pgbouncer, etc.)
- Not currently implemented but recommended for production

**10. Schema Initialization**
- Initialize schemas during pool creation (lines 145-177)
- Use migrations for schema versioning (lines 159-177)
- Store schema version in database (lines 229-270)
- Fail fast if schema initialization fails (lines 417-419)

**11. Error Handling**
- Pool initialization errors fail application startup (lines 48-50)
- Connection acquire errors logged and re-raised (line 130)
- Cleanup errors logged but don't fail shutdown (lines 55-56, 60-61)
- Reference defensive error handling patterns throughout

**12. Testing with Connection Pools**
- Mock pool creation in tests (reference `tests/unit/test_validation_errors.py` lines 29-39)
- Use in-memory databases for integration tests
- Override pool dependencies with test pools
- Reference `tests/conftest.py` for test fixture patterns

**13. Anti-Patterns to Avoid**
- Creating new pools per request (kills performance)
- Not using connection pooling (thrashes connections)
- Massive pool sizes (exhausts database resources)
- Not setting timeouts (hangs on connection exhaustion)
- Not cleaning up pools on shutdown (resource leaks)