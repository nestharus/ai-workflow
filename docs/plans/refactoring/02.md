I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\service-patterns.md(NEW)

References:

- app\services\example_service.py
- app\api\v1\endpoints\example.py
- app\core\dependencies.py
- app\infrastructure\db_connections.py
- app\core\factory.py
- docs\docstrings-guide.md

Create service layer patterns documentation covering:

**1. Service Layer Responsibilities**
- **Scope**: Encapsulate business logic and core use cases.
- **Orchestration**: Coordinate high-level workflows involving multiple repositories or external clients (e.g., database + search index).
- **Transaction Management**: Define the "Unit of Work" boundaries (commit on success, rollback on failure) to ensure data consistency.
- **Constraint**: Services must remain **HTTP-agnostic**. Never import `fastapi`, `starlette`, or `Request`/`Response` objects.

**2. Service Class Structure**
- **Constructor (`__init__`)**: Explicitly declare all dependencies (repositories, clients, settings).
- Methods represent business operations (verbs: `create_user`, `process_order`)
- **Cleanup**: Mandatory `shutdown()` method for resource cleanup.
- Use type hints for all parameters and return values
- Document exceptions in docstrings using Google style (reference `docs/docstrings-guide.md`)
- **Example Pattern**:
  ```python
  class DomainService:
      def __init__(self, repo: Repository, settings: Settings):
          self.repo = repo

      def process_item(self, item_id: str) -> DomainModel:
          # ... logic ...
          pass

      def shutdown(self) -> None:
          # ... cleanup ...
          pass
  ```

**3. Dependency Injection Pattern**
- Services receive dependencies via constructor, not as globals
- Example: `ExampleService(prefix="[DEMO]")` in `app/api/v1/endpoints/example.py` line 17
- For database access, inject session/pool from request context
- For settings, inject via dependency (reference `app/core/dependencies.py`)

**4. Transaction Management**
- Services should manage transaction boundaries (commit/rollback)
- For async operations, use `async with pool.acquire()` pattern (reference `app/infrastructure/db_connections.py` lines 122-135)
- Rollback on domain exceptions, commit on success
- Example pattern: service method calls multiple repository methods, then commits once

**5. Error Handling in Services**
- Raise domain-specific exceptions (e.g., `UserNotFoundError`, `InvalidOperationError`)
- Do NOT raise `HTTPException` (that's for routers)
- Let global exception handlers convert domain errors to HTTP responses
- Document all possible exceptions in method docstrings

**6. Service Testing Strategy**
- Unit test services with mocked repositories (no database)
- Integration test services with real repositories and test database
- Use dependency injection to swap implementations
- Example: `tests/conftest.py` shows fixture patterns for test isolation

**7. Service Lifecycle**
- Services are typically request-scoped (created per request)
- For long-lived services (background tasks), implement proper cleanup
- Use `shutdown()` method for resource cleanup
- Reference lifespan management in `app/core/factory.py` lines 33-63

**8. Anti-Patterns to Avoid**
- Services that are just thin wrappers around repositories (no business logic)
- Services that import FastAPI types (Request, Response, HTTPException)
- Services that directly access `app.state` or global variables
- Services that mix multiple unrelated business domains
- Services that perform I/O without proper async/await