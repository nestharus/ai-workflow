I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\repository-patterns.md(NEW)

References:

- app\infrastructure\db_connections.py
- app\core\factory.py
- tests\conftest.py

Create repository patterns documentation covering:

**1. Repository Pattern Purpose**
- Abstracts data access logic from business logic
- Provides clean interface for CRUD operations
- Enables testing with mock repositories
- Supports multiple data sources (SurrealDB, Elasticsearch)
- Reference 2024 best practices: repository per aggregate/entity

**2. Repository Interface Design**
- Define protocol/interface for each repository (optional but recommended)
- Common methods: `get_by_id`, `get_by_field`, `list`, `create`, `update`, `delete`
- Use type hints for all parameters and return values
- Example: `async def get_by_id(self, id: str) -> Entity | None`

**3. Repository Implementation**
- One repository class per entity/aggregate
- Constructor accepts session/connection, not global access
- Example: `class UserRepository: def __init__(self, session: AsyncSession)`
- Use async methods for all database operations
- Reference `app/infrastructure/db_connections.py` for connection patterns

**4. SurrealDB Repository Pattern**
- Use `async with pool.acquire() as conn` for connection management (reference lines 122-135)
- Execute queries with `await conn.query(sql, params)`
- Handle schema migrations in pool initialization (lines 145-177)
- Use parameterized queries to prevent injection
- Example: `await conn.query("SELECT * FROM users WHERE id = $id", {"id": user_id})`

**5. Elasticsearch Repository Pattern**
- Use wrapper methods from `ElasticsearchWrapper` (reference lines 273-401)
- Methods: `search`, `index`, `bulk`, `create_index`
- All methods run in threadpool via `anyio.to_thread.run_sync` (lines 304, 320, 331)
- Initialize indices during startup (lines 364-400)

**6. Transaction Management**
- Repositories should NOT commit transactions
- Let service layer manage transaction boundaries
- Use `flush()` instead of `commit()` in repositories
- Example: `await session.flush(); await session.refresh(obj)`

**7. Query Patterns**
- Use parameterized queries for safety
- Implement pagination with `skip` and `limit` parameters
- Return domain models, not raw database results
- Example: `async def list(self, skip: int = 0, limit: int = 100) -> list[Entity]`

**8. Error Handling in Repositories**
- Let database errors propagate (don't catch and hide)
- Raise specific exceptions for known error cases
- Example: `ResourceNotFoundError` when entity doesn't exist
- Log database errors before re-raising

**9. Repository Testing**
- Unit test with mocked connections (no real database)
- Integration test with test database (in-memory or container)
- Use fixtures to provide test repositories
- Reference `tests/conftest.py` for test database setup patterns

**10. Repository Factory Pattern**
- Create factory functions for repositories
- Example: `def get_user_repository(session: AsyncSession) -> UserRepository`
- Use dependency injection to provide repositories to services
- Store connection pools in `app.state` (reference `app/core/factory.py` lines 40-44)

**11. Generic Repository (Optional)**
- Consider generic base repository for common CRUD operations
- Use only if it reduces duplication without adding complexity
- Prefer explicit repositories for clarity
- 2024 best practice: explicit repositories per entity are clearer

**12. Anti-Patterns to Avoid**
- Repositories that commit transactions (breaks composability)
- Repositories that contain business logic (use services)
- Repositories that return ORM models instead of domain models
- Global repository instances (use dependency injection)
- Over-generic repositories that obscure actual operations