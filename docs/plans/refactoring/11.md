I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\api-testing-patterns.md(NEW)

References:

- tests\conftest.py
- tests\unit\test_validation_errors.py
- tests\e2e\test_health.py
- app\core\factory.py
- app\core\settings.py

Create API testing patterns documentation covering:

**1. Testing Architecture**
- Two-tier testing: integration (fast) and E2E (slow)
- Integration tests: in-process with `httpx.ASGITransport` (reference `tests/conftest.py` lines 109-116)
- E2E tests: live server with Docker (lines 157-228)
- Mark E2E tests with `@pytest.mark.e2e` (reference `tests/e2e/test_health.py` line 6)

**2. Test Fixtures Organization**
- Centralize fixtures in `tests/conftest.py` (reference lines 1-19 for documentation)
- Provide `test_settings` fixture (lines 73-83)
- Provide `test_app` fixture (lines 86-89)
- Provide `client` fixture for sync tests (lines 92-96)
- Provide `async_client` fixture for async tests (lines 109-116)

**3. Dependency Overrides Pattern (2024 Best Practice)**
- Use `app.dependency_overrides` instead of monkeypatch
- Set overrides before creating TestClient
- Always reset after test: `app.dependency_overrides = {}`
- Example pattern:
  ```python
  @pytest.fixture
  def client():
      app.dependency_overrides[get_db] = get_test_db
      with TestClient(app) as c:
          yield c
      app.dependency_overrides = {}
  ```

**4. Mocking External Dependencies**
- Current approach uses monkeypatch (reference lines 29-39)
- Migrate to dependency_overrides pattern
- Mock database pools, external APIs, settings
- Example: override `get_surrealdb_pool` with fake pool
- Keep mocks simple: return dummy objects with required interface

**5. Settings Override Pattern**
- Create test settings with safe defaults (lines 46-51)
- Override specific fields for test scenarios
- Use `model_copy(update={...})` for variations (line 103)
- Example: `Settings(include_error_body=True, surrealdb_user=test_user, ...)`

**6. Integration Test Patterns**
- Use `async_client` fixture for async endpoints
- Test full request/response cycle without network
- Mock external dependencies (DB, cache, APIs)
- Fast execution (no Docker, no network)
- Example: `tests/unit/test_validation_errors.py` shows validation testing

**7. E2E Test Patterns**
- Use `api_client` fixture for live server tests (lines 231-235)
- Test against real Docker stack (lines 157-228)
- Verify full stack including startup scripts
- Slow execution but high confidence
- Example: `tests/e2e/test_health.py` shows E2E testing

**8. Test Database Setup**
- Use separate test database or in-memory database
- Initialize schema before tests
- Clean up data between tests (transactions or truncate)
- Reference `tests/conftest.py` for database fixture patterns

**9. Assertion Patterns**
- Use `pytest-check` for multiple soft assertions (reference `tests/e2e/test_health.py` lines 20-21)
- Check status code first, then response body
- Validate response against Pydantic models
- Example: `check.equal(response.status_code, 200)`

**10. Testing Validation Errors**
- Test with invalid input to trigger validation errors
- Verify error response format (reference `tests/unit/test_validation_errors.py`)
- Test with and without `include_error_body` setting (lines 70-85)
- Verify error details match expected structure (lines 19-26)

**11. Docker-Based E2E Testing**
- Use `docker-compose` for full stack (lines 169-175)
- Wait for health check before running tests (lines 176-190)
- Capture logs on failure (lines 193-203)
- Clean up containers after tests (lines 215-228)
- Use ephemeral port to avoid conflicts (lines 122-140)

**12. Test Organization**
- `tests/unit/`: Fast unit tests with mocks
- `tests/integration/`: Integration tests with test DB
- `tests/e2e/`: End-to-end tests with live server
- Run fast tests by default: `pytest -m "not e2e"`
- Run all tests in CI: `pytest`

**13. Anti-Patterns to Avoid**
- Using monkeypatch for dependency injection (use dependency_overrides)
- Not resetting dependency_overrides after tests (causes leakage)
- Mixing integration and E2E tests (separate clearly)
- Not using fixtures for common setup (DRY principle)
- Testing implementation details instead of behavior