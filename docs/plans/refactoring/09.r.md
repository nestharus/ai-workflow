Plan 09 – docs/repository-patterns.md (Repository Layer
Patterns)
Intro Proposal:
NOTE TO GENERATOR (DO NOT EMIT IN OUTPUT):

You are generating `docs/repository-patterns.md`, one document in a FastAPI backend patterns series.

Global goals:
- Document the repository/data-access layer as an abstraction over SurrealDB, Elasticsearch, or any future stores.
- Follow best practices from `fastapi-best-practices.md` / `fastapi-best-practices-2.md` and modern repository patterns.
- Use inline, storage-agnostic examples wherever possible; avoid line-precise references to existing implementations.

Specific scope for `repository-patterns.md`:
- Define the purpose of repositories and how they isolate data access from services.
- Suggest designing per-aggregate or per-entity repository interfaces (Protocols) with clear CRUD and query methods.
- Describe how repositories interact with connection pools and sessions (SurrealDB, Elasticsearch).
- Clarify that repositories do not manage transactions/commits; that is a service-layer responsibility.
- Describe query patterns (parameterized queries, pagination, filtering) and mapping to domain models rather than raw DB results.
- Explain repository-level error handling: what to raise for not-found vs letting unexpected DB errors bubble up.
- Outline repository testing strategies: unit tests with fake connections, integration tests with real test databases/indices.

Out of scope:
- Service orchestration and business rules (in `service-patterns.md`).
- Connection pool details (in `connection-pooling-patterns.md`).

The final document should start with the repository patterns heading, not this note.
Mistakes/Issues:
- SurrealDB vs SQLAlchemy context: The plan mixes patterns that apply to ORMs (e.g. transaction
  management with session.flush() and session.refresh() ) with the actual technologies in use
  (SurrealDB, Elasticsearch). If SurrealDB is being used directly (without an ORM), talking about sessions and
  flush may not apply. This could confuse readers. To avoid this, clarify which parts apply generally vs.
  specifically: e.g. “For relational databases (if using an ORM like SQLAlchemy), repositories should call
  session.flush() instead of commit, and let the service commit. In our case with SurrealDB, each query
  is auto-committed, so this point is more relevant for when a transactional DB is introduced.” This way, the
  advice is accurate and doesn’t seem out-of-place.
- Line references: The plan heavily cites db_connections.py line ranges for Surreal and ES
  implementations. These should be translated into descriptive text or pseudo-code. For example, explain
  how the SurrealDB connection is acquired (likely an asyncio.Queue or a connection pool object).
  Similarly, instead of “lines 273-401” for ElasticsearchWrapper , summarize the key methods provided
  (search, index, bulk, etc.) in a list or short description. The goal is to document the pattern (abstracting the
  data store behind repository methods), not the exact code implementation line-by-line.
- Repository interface/protocol: It suggests defining an interface (Protocol) for each repository which is
  great. However, ensure the doc gives a clear example of what that means. Perhaps include a small snippet:
  class UserRepositoryProtocol(Protocol):
  async def get_by_id(self, id: str) -> User | None: ...
  async def list(...) -> list[User]: ...
# etc.
This shows how one might define the abstract interface. If this isn’t actually implemented in code yet,
present it as a recommendation (“consider using typing.Protocol for repository interfaces”). Without an
example, readers may not grok “interface (optional but recommended)”.
Missing Best Practices:
- Pagination in repository methods: The Query Patterns section mentions implementing pagination with
  skip and limit . If the API uses page/pageSize, the repository might instead take offset and
  limit . It might be worth reconciling this with the API design: for instance, advise that repository methods
  use low-level offset/limit, while services or routers handle converting page->offset. If that’s too detailed, at
  least ensure the pattern doc and API doc aren’t promoting two different pagination methods. Currently, API
  Patterns (Plan 01) implies page-based, while this repository section says skip/limit. Make a note in
  documentation to avoid confusion (e.g. “(skip and limit correspond to page and pageSize in API requests)”).
- Error handling strategy: The plan says “raise specific exceptions (e.g. ResourceNotFoundError ) in
  repositories for known cases.” One best practice here: Only do this for expected conditions (like no data
  found), and let unexpected database errors (connection issues, timeouts) bubble up as is (which will likely
  become 500s). The doc should encourage letting low-level exceptions propagate unless there’s a clear
  recovery or translation. This seems to be the intent, but stating it clearly: “Do not catch broad database
  exceptions in the repository – allow them to propagate so that the global error handler can treat them (likely as
  internal errors). Only catch and raise domain-specific errors for scenarios that aren’t truly errors (e.g. not-found,
  unique constraint violation translating to a Conflict error, etc.).”
- Batch operations: You covered single-entity CRUD well. Perhaps mention if there’s a pattern for bulk
  operations. Given the presence of an Elasticsearch wrapper (with bulk indexing) and possibly SurrealDB
  migrations, maybe note: “For batch operations (multiple entities), repositories can provide specialized
  methods (e.g. bulk_insert ) or rely on service layer to loop transactions. Prefer repository-level bulk
  methods if the underlying database can handle them efficiently (e.g. Elasticsearch bulk API).” This is a minor
  addition for completeness.
- Testing repositories: The plan’s testing section is good (mock vs integration with test DB). You might add:
  if using an in-memory or Dockerized database for integration tests, ensure tests reset the state between
  runs (e.g. by wiping collections or using transactions). It says “truncate or transactions” in Plan 11’s test doc;
  perhaps echo a bit of that here or reference the testing patterns doc for how the test DB is managed.
- Cross-reference service layer: Since repositories are tightly connected to the service layer, consider
  adding a reference: e.g. “(See Service Layer Patterns for how services orchestrate repositories and manage
  transactions).” This reminds readers that these two docs are two sides of the same coin and helps reduce
  duplication of explanation.