I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\api-patterns.md(NEW)

References:

- app\api\v1\router.py
- app\api\v1\endpoints\example.py
- app\api\v1\endpoints\health.py
- app\contracts\example_contract.py
- app\contracts\errors.py
- app\core\factory.py

Create comprehensive API patterns documentation covering:

**1. URL Structure & Versioning**
- **Versioning Strategy**: Use path-based versioning for all API endpoints (e.g., `/api/v1`, `/api/v2`).
- **Health Checks**:
    - Liveness: `/health` (unversioned).
    - Readiness: `/api/{version}/health` (versioned, documented).
- RESTful resource naming conventions use plural nouns and kebab-case (`/users`, `/items`)
- Path parameter conventions use specific identifiers: `/{resource_id}` not `/{id}`

**2. HTTP Methods & Status Codes**
- GET: 200 (success), 404 (not found)
- POST: 201 (created), 400 (validation error), 409 (conflict)
- PUT/PATCH: 200 (success), 404 (not found)
- DELETE: 204 (no content), 404 (not found)
- **Validation Rule**: Explicitly document that **400 Bad Request** is used for validation errors (overriding FastAPI's default 422).

**3. Request/Response Patterns**
- **Requests**: Must use Pydantic models with `ConfigDict(extra="forbid")`.
- **Responses**: Use `response_model` parameter in route decorators for automatic validation
- **Example Pattern**:
  ```python
  class ResourceCreate(BaseModel):
      model_config = ConfigDict(extra="forbid")
      name: Annotated[str, Field(min_length=1)]
  class ResourceResponse(BaseModel):
      model_config = ConfigDict(extra="forbid")
      id: int
      name: str
      created_at: datetime
  ```

**4. OpenAPI Documentation Standards (Pydantic V2)**
- Every endpoint must have `summary` (short description)
- Complex endpoints need `description` (detailed explanation)
- Use `tags` for logical grouping (e.g., tags=["Users"]).
- Error Documentation: Must use the responses argument to document non-200 outcomes.
- Schema: Reference app/contracts/errors.py for 400-type response models.

**5. Response Envelope Pattern**
- Do NOT wrap responses in generic envelopes like `{"data": ..., "status": ...}`
- For pagination, use generic `Paginated[T]` model
- For errors, use structured `HTTPValidationError` model (reference `app/contracts/errors.py`)

**6. Content Negotiation**
- JSON Engine: ORJSONResponse is the required default_response_class.
- Content-Type: Defaults to application/json.
- Support `Accept-Encoding: gzip` via middleware

**7. API Versioning Strategy**
- Path Versioning: Use URL path versioning (e.g., /api/v1, /api/v2).
- Maintain backward compatibility within major versions
- Deprecation:
  - Mark endpoints as deprecated using deprecated=True. 
  - Include a Sunset HTTP header if a removal date is scheduled.
- Document breaking changes in API changelog

**8. Anti-Patterns to Avoid**
- Mixing business logic in route handlers (use services)
- Exposing DB Models: Never return ORM models directly (always use Pydantic schemas)
- Inconsistent error response formats
- Missing OpenAPI documentation
- Using generic exception handlers that hide error details