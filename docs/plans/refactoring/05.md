I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with modern FastAPI and Pydantic v2 patterns, including lifespan management in `app/core/factory.py`, async connection pooling in `app/infrastructure/db_connections.py`, and proper test fixtures in `tests/conftest.py`. However, there's no centralized documentation of these patterns, and some areas need alignment with 2024-2025 best practices:

**Current Strengths:**
- Pydantic v2 with `ConfigDict(extra="forbid")` in contracts
- Async connection pooling for SurrealDB and Elasticsearch
- Lifespan management with proper startup/shutdown
- ORJSONResponse for performance
- Structured test fixtures with integration and E2E separation

**Gaps Identified:**
- No unified error handling with `AppError`/`DomainError` pattern
- No generic `Paginated[T]` model for consistent pagination
- Dependency injection scattered across files (inline in routers)
- No repository pattern documentation or implementation
- Testing uses monkeypatch instead of `dependency_overrides`
- No middleware stack documentation (security headers, compression)
- Missing comprehensive pattern documentation

**Research Findings:**
From FastAPI docs and 2024 best practices, the following patterns should be documented:
1. Centralized dependency injection with `Annotated` type aliases
2. Unified error handling with custom exception handlers
3. Repository pattern for data access abstraction
4. Middleware ordering (TrustedHost → Security → GZip)
5. Testing with `app.dependency_overrides` instead of monkeypatch
6. Generic Pydantic models for pagination
7. Service layer that raises domain exceptions

### Approach

Create 1 comprehensive Markdown documentation file in `docs/` that establish patterns for the entire FastAPI application architecture. Each file will:

1. Define the pattern with clear rationale
2. Provide code examples from the existing codebase where applicable
3. Include 2024-2025 best practices from FastAPI and Pydantic v2
4. Reference related patterns in other documentation files
5. Include anti-patterns to avoid

The documentation will serve as the single source of truth for development patterns, ensuring consistency across the codebase and enabling future refactoring phases to align with these standards.

### Reasoning

I explored the current codebase structure by reading key files including `app/core/factory.py`, `app/infrastructure/db_connections.py`, `tests/conftest.py`, and various contracts, services, and routers. I then used context7 to resolve FastAPI and Pydantic library documentation, firecrawl to scrape official FastAPI documentation on dependencies, error handling, middleware, and bigger applications, and web search to find 2024 best practices for repository patterns, connection pooling, and testing with dependency_overrides. This comprehensive research provided the foundation for creating detailed pattern documentation.

## Proposed File Change

### docs\dependency-patterns.md(NEW)

References:

- app\core\dependencies.py
- app\api\v1\endpoints\example.py
- app\infrastructure\db_connections.py
- app\core\factory.py
- tests\conftest.py

Create dependency injection patterns documentation covering:

**1. Dependency Injection Fundamentals**
- Use `Depends()` for injecting dependencies into route handlers
- Dependencies are functions that can take parameters themselves
- FastAPI resolves dependency tree automatically
- Reference FastAPI docs: dependencies can be async or sync

**2. Annotated Type Aliases (2024 Best Practice)**
- Create reusable type aliases with `Annotated` for common dependencies
- Example: `CommonsDep = Annotated[dict, Depends(common_parameters)]`
- Reduces duplication and improves type safety
- Store in centralized `app/api/v1/dependencies.py` (to be created)

**3. Centralized Dependency Providers**
- Create `app/api/v1/dependencies.py` for all dependency functions
- Move `get_example_service` from `app/api/v1/endpoints/example.py` line 15
- Add `get_surrealdb_pool`, `get_elasticsearch_client` that access `request.app.state`
- Re-export `get_settings` from `app/core/dependencies.py` for convenience

**4. Database Session Dependencies**
- Provide session/connection via dependency, not global
- Use `yield` pattern for automatic cleanup
- Example pattern for SurrealDB: `async with pool.acquire() as conn: yield conn`
- Reference `app/infrastructure/db_connections.py` lines 122-135 for acquire pattern

**5. Settings Dependency**
- Use `@lru_cache` for singleton settings (reference `app/core/dependencies.py` lines 8-11)
- Inject via `Depends(get_settings)` in routes that need configuration
- Override in tests using `app.dependency_overrides` (to be documented)

**6. Service Dependencies**
- Create factory functions that instantiate services with dependencies
- Example: `get_example_service()` returns `ExampleService(prefix="[DEMO]")` (reference `app/api/v1/endpoints/example.py` lines 15-17)
- Services can depend on other dependencies (session, settings, etc.)

**7. Request-Scoped vs Singleton Dependencies**
- Request-scoped: database sessions, current user, request context
- Singleton: settings (via `@lru_cache`), connection pools (in `app.state`)
- Connection pools initialized once in lifespan, accessed via `app.state`
- Reference `app/core/factory.py` lines 40-44 for state storage

**8. Dependency Chains**
- Dependencies can depend on other dependencies
- FastAPI resolves the entire tree automatically
- Example: service depends on session, session depends on pool from `app.state`
- Keep chains shallow for maintainability (max 2-3 levels)

**9. Router-Level Dependencies**
- Apply dependencies to entire router using `dependencies` parameter
- Example: `APIRouter(dependencies=[Depends(verify_token)])`
- Useful for authentication, rate limiting, logging
- Executed before route-specific dependencies

**10. Testing with Dependency Overrides**
- Use `app.dependency_overrides` dict to replace dependencies in tests
- Example: `app.dependency_overrides[get_db] = get_test_db`
- Always reset after test: `app.dependency_overrides = {}`
- Reference `tests/conftest.py` for fixture patterns (to be updated)

**11. Anti-Patterns to Avoid**
- Creating dependencies inside route handlers (defeats caching)
- Using global variables instead of dependency injection
- Not using `yield` for cleanup in dependencies with resources
- Circular dependencies between modules
- Over-nesting dependencies (keep it simple)